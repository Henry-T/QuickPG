模板预制在ListView之内

- 为何必须对模板做拷贝？
  如果模板是ListView内部版本，在数据绑定时需要首先拷贝出所有实例，然后清空ListView(ListView对单独删除支持很差，需序号)。再将拷贝示实例一一添加到ListView中。
  最大的问题在于，上述过程完成之后，ListView中的模板再也无法访问，即使在lua中保留引用，ListView的删除子对象方法是释放内存的，该引用的C++部分已经丢失了。
  随后再次打开面板绑定数据时，模板没有了，还如何创建实例？这就是为何要做模板拷贝的原因。

- 模板拷贝为何会被删除？
  随后尝试了在初次载入面板时，做一份模板拷贝(Widget::Clone())。此时这个拷贝与Panel本身没有关系，因此Panel是否retain都无所谓。但是在再次加载时这个拷贝仍然无法使用了。报错基本上是这种形式的"invalid 'self' in function '<Function_Name>'"。function当然都是C++的函数。对于这个结果，似乎只能解释为C++对象被释放了，难道引擎部分自动释放C++引用数为0的控件吗？
  可能的解决方案：retain能否应用到控件上？

- 可惜可惜，setpeer不能解决问题
  clone之后peertable信息丢失似乎不可避免，setpeer会导致错位