<核心>
- 提取Panel名称做为类名

<容器>
- 结构化的容器代码

<增量>
- 增量时保留 保留已有回调等
- 增量时新增 在尾项后面继续添加

<额外>
- 自动创建备份
- Shell快速执行

* 尽量让生成代码处于蜷缩态，手写代码使用简单接口接入生成代码
* 绝对要避免结构树！！！！！ 找到巧妙的特征判断！！！！！

<匹配方法>
匹配类名              - 匹配类别("name": "Panel*")，唯一匹配结果
匹配所有全局控件      - 匹配类别("name": "lb*" 等)，匹配结果中上溯N个{}对之后，没有widget父级，匹配成立
匹配所有容器          - 匹配类别("name": "list*")，所有匹配结果都成立
匹配所有容器子控件    - 匹配类别("name": "lb*" 等)，匹配结果中上溯N个{}对之后，找到widget父级，匹配成立
* 更简单的做法

<关键问题>
如何判断一个基础控件是否顶级控件?
做如下正则匹配
{1-控件名称}{...}{2-控件名称后下一个换行到再下一个非空格}{...}{3-模板名称前一个换行到更近的一个非空格符}{...}{4-模板名称}
有几种情况：
 - 如果匹配不到，该控件为Top控件
 - 如果2的长度大于3，该控件为子控件，否则为Top控件、

<注意事项>
导出控件不管在任意层级，绝对不可同名



<第一阶段> - [OK] 生成基础空框架代码

<第二阶段> - [OK] 匹配类名并生成空类

<第三阶段> - [OK] 无干扰匹配并生成全局控件

<第四阶段> - [OK] 解析容器及容器模板

<第五阶段> - [OK] 区分Top控件及容器子控件

<第六阶段> - [OK] 容器子控件代码生成 (因lua限制,需在add函数中进行)

<第七阶段> - [Del] 容器通用处理

<第八阶段> - [OK] 容器子模板事件处理

<第九阶段> - [] 增量时自定义区块的备份和还原

借助“交互”字段，完美的自定义数据